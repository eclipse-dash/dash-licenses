/*************************************************************************
 * Copyright (c) 2019,2023 The Eclipse Foundation and others.
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this
 * distribution, and is available at https://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 *************************************************************************/
package org.eclipse.dash.licenses;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.eclipse.dash.licenses.util.MavenCoordinatesParser.parse;

public class MavenIdParser implements ContentIdParser {
	/**
	 * We set the type and source to "p2" and "orbit" when we encounter something
	 * with a p2 prefix. We had previously grabbed this value directly from Tycho
	 * (<code>org.eclipse.tycho:org.eclipse.tycho.embedder.shared</code>) but doing
	 * so periodically introduced incompatibilities after updates. Also... we really
	 * only need this value and really don't expect it to change, so pulling in even
	 * just an entire class seems excessive.
	 */
	private static final String P2_GROUPID_PREFIX = "p2.";

	/**
	 * We use this regular expression to pull the Maven identifier out of a string.
	 * Strictly speaking, this isn't necessarily a GAV, but we use that term for
	 * convenience. The identifier may have three, four, or five segments; we've had
	 * trouble getting regular expressions to work consistently, so this regular
	 * expression is used only to coarse-grained get the identifier out of a string.
	 * 
	 * See comments on {@link #normalise(String)}. Also see
	 * {@link MavenCoordinatesParser#parse(String)}
	 */
	private Pattern gavPattern  = Pattern.compile("\\b[\\w\\.\\-_]+(?::[\\w\\.\\/\\-_]+){2,4}\\b");
	private Pattern antBundleClassifierPattern = Pattern.compile("lib/(?<artifactid>.*)\\.jar");
	private Pattern semanticVersionPattern = Pattern.compile("(?<version>\\d+(?:\\.\\d+){1,2}).*");

	@Override
	public IContentId parseId(String value) {
		/*
		 * We originally implemented this using Aether, but Aether breaks when a phase
		 * is included in the value. So, we brute force it.
		 */
		
		var mavenCoordinates = parse(normalise(value));
		if (mavenCoordinates == null) return null;

		String type = mavenCoordinates.groupId.startsWith(P2_GROUPID_PREFIX) ? "p2" : "maven";
		String source = mavenCoordinates.groupId.startsWith(P2_GROUPID_PREFIX) ? "orbit" : "mavencentral";

		/*
		 * So this is a complete hack. If we're looking at the Apache Ant bundle, then
		 * use the classifier to sort out the actual Maven GAV. 
		 */
		// FIXME Find a more general solution
		if ("p2".equals(type) && "org.apache.ant".equals(mavenCoordinates.artifactId) && !mavenCoordinates.classifier.isEmpty()) {
			Matcher classifierMatcher = antBundleClassifierPattern.matcher(mavenCoordinates.classifier);
			if (classifierMatcher.matches()) {
				type = "maven";
				source = "mavencentral";
				var groupid = mavenCoordinates.artifactId;
				var artifactid = classifierMatcher.group("artifactid");
				var version = mavenCoordinates.version;
				
				Matcher semanticVersionMatcher = semanticVersionPattern.matcher(version);
				if (semanticVersionMatcher.matches()) {
					version = semanticVersionMatcher.group("version");
				}
				return ContentId.getContentId(type, source, groupid, artifactid, version);
			}
		}

		return ContentId.getContentId(type, source, mavenCoordinates.groupId, mavenCoordinates.artifactId, mavenCoordinates.version);
	}
	
	/**
	 * Extract out what is probably the actual ID from the input.
	 * 
	 * The list generated by the <code>dependency:list</code> plugin may contain
	 * module information. Let's make sure that we can handle this format.
	 * 
	 * <pre>
	 *   com.github.peteroupc:numbers:jar:1.8.2:compile -- module numbers (auto)
	 *   org.bouncycastle:bcpkix-jdk18on:jar:1.78.1:compile -- module org.bouncycastle.pkix
	 *   org.bouncycastle:bcprov-jdk18on:jar:1.78.1:compile -- module org.bouncycastle.provider
	 *   org.bouncycastle:bcutil-jdk18on:jar:1.78.1:compile -- module org.bouncycastle.util
	 *   org.junit.jupiter:junit-jupiter:jar:5.11.4:test -- module org.junit.jupiter
	 * </pre>
	 * 
	 * The <code>dependency:tree</code> plugin presents data in a different format.
	 * 
	 * <pre>
	 * +- decentralized-identity:did-common-java:jar:1.11.0:compile
	 * |  +- decentralized-identity:jsonld-common-java:jar:1.8.0:compile
	 * |  |  +- com.apicatalog:titanium-json-ld:jar:1.3.2:compile
	 * |  |  +- io.setl:rdf-urdna:jar:1.2:compile
	 * |  |  \- org.glassfish:jakarta.json:jar:2.0.1:compile
	 * |  +- org.apache.httpcomponents:httpclient:jar:4.5.14:compile
	 * |  |  +- org.apache.httpcomponents:httpcore:jar:4.4.16:compile
	 * |  |  \- commons-logging:commons-logging:jar:1.2:compile
	 * |  +- commons-codec:commons-codec:jar:1.17.2:compile
	 * |  +- com.sabnf:apg:jar:1.1.0:compile
	 * |  \- com.upokecenter:cbor:jar:4.5.2:compile
	 * |     \- com.github.peteroupc:numbers:jar:1.8.2:compile
	 * </pre>
	 * 
	 * In order to handle all of the above, we use a regular expression to try and
	 * identify a three- to five-part "GAV" somewhere in the content.
	 */
	private String normalise(String value) {
		var matcher = gavPattern.matcher(value);
		if (matcher.find()) return matcher.group();
		return value;
	}
}
